<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtest Results - PyTAAA Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin-bottom: 20px;
            transition: background 0.3s;
        }
        
        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        label {
            font-weight: 600;
            color: #333;
        }
        
        select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            background: white;
            color: #333;
            min-width: 200px;
        }
        
        select:focus {
            outline: none;
            border-color: #764ba2;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 500px;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        h2 {
            margin: 0;
            color: #333;
            font-size: 1.5rem;
        }
        
        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .chart-controls label {
            font-weight: 600;
            color: #333;
        }
        
        .chart-controls select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            background: white;
            color: #333;
            min-width: 200px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-size: 1.2rem;
        }
        
        .error {
            background: #fee;
            border: 2px solid #fcc;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #c33;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/static/dashboard.html" class="back-link">‚Üê Back to Dashboard</a>
            <h1>üìà Backtest Results</h1>
            <p class="subtitle">Historical model performance analysis</p>
        </header>

        <div id="errorContainer"></div>

        <!-- Phase 5A MVP: Subplot 1 only - Portfolio Value Comparison -->
        <div class="chart-container">
            <div class="chart-header">
                <h2>Portfolio Value: Model vs Buy-and-Hold</h2>
                <div class="chart-controls">
                    <label for="modelSelect">Select Model:</label>
                    <select id="modelSelect">
                        <option value="">Loading models...</option>
                    </select>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="portfolioChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let models = [];
        let currentModelId = null;
        let portfolioChart = null;

        // Chart colors (matching recommendation_plot.png styling)
        const COLORS = {
            traded: '#1f77b4',      // Blue - model-switched portfolio
            buyHoldNaz: '#2ca02c',  // Green - NASDAQ buy-and-hold
            buyHoldSp: '#ff7f0e'    // Orange - S&P 500 buy-and-hold
        };

        // Initialize
        async function init() {
            try {
                await loadModels();
                setupEventListeners();
            } catch (error) {
                showError('Failed to initialize: ' + error.message);
            }
        }

        // Load available models
        async function loadModels() {
            try {
                const response = await fetch('/api/v1/models');
                if (!response.ok) throw new Error('Failed to fetch models');
                
                models = await response.json();
                const modelSelect = document.getElementById('modelSelect');
                
                modelSelect.innerHTML = '<option value="">-- Select a model --</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = `${model.name} (${model.index_type})`;
                    modelSelect.appendChild(option);
                });
                
                // Auto-select first non-meta model if available
                const firstModel = models.find(m => !m.is_meta);
                if (firstModel) {
                    modelSelect.value = firstModel.id;
                    await loadBacktestData(firstModel.id);
                }
            } catch (error) {
                showError('Failed to load models: ' + error.message);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('modelSelect').addEventListener('change', async (e) => {
                if (e.target.value) {
                    await loadBacktestData(e.target.value);
                }
            });
        }

        // Load backtest data for selected model
        async function loadBacktestData(modelId) {
            try {
                clearError();
                currentModelId = modelId;
                
                const response = await fetch(`/api/v1/models/${modelId}/backtest`);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error('No backtest data available for this model. Please ingest data first.');
                    }
                    throw new Error('Failed to fetch backtest data');
                }
                
                const data = await response.json();
                renderPortfolioChart(data);
            } catch (error) {
                showError(error.message);
                if (portfolioChart) {
                    portfolioChart.destroy();
                    portfolioChart = null;
                }
            }
        }

        // Render Portfolio Value Chart (Subplot 1)
        function renderPortfolioChart(data) {
            const ctx = document.getElementById('portfolioChart');
            
            if (portfolioChart) {
                portfolioChart.destroy();
            }
            
            // Prepare datasets
            const dates = data.data_points.map(d => d.date);
            const tradedValues = data.data_points.map(d => d.traded_value);
            const buyHoldValues = data.data_points.map(d => d.buy_hold_value);
            
            // Determine if this is NASDAQ or S&P 500 model
            const isNasdaq = data.index_type === 'NASDAQ_100';
            const buyHoldColor = isNasdaq ? COLORS.buyHoldNaz : COLORS.buyHoldSp;
            const buyHoldLabel = isNasdaq ? 'Buy & Hold (NASDAQ 100)' : 'Buy & Hold (S&P 500)';
            
            portfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [
                        {
                            label: data.model_name,
                            data: tradedValues,
                            borderColor: COLORS.traded,
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0
                        },
                        {
                            label: buyHoldLabel,
                            data: buyHoldValues,
                            borderColor: buyHoldColor,
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'chartArea',
                            align: 'start',
                            labels: {
                                usePointStyle: false,
                                boxWidth: 60,
                                boxHeight: 1.5
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'year',
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            min: 10000, // Start at $10K
                            max: 100000000000, // 100B
                            title: {
                                display: true,
                                text: 'Portfolio Value ($) - Log Scale'
                            },
                            ticks: {
                                callback: function(value) {
                                    // Only show major ticks (powers of 10)
                                    const log = Math.log10(value);
                                    if (Math.abs(log - Math.round(log)) < 0.001) {
                                        // Format as K, M, B with spaces
                                        if (value >= 1000000000) {
                                            return '$' + (value / 1000000000) + ' B';
                                        } else if (value >= 1000000) {
                                            return '$' + (value / 1000000) + ' M';
                                        } else if (value >= 1000) {
                                            return '$' + (value / 1000) + 'K';
                                        }
                                        return '$' + value.toLocaleString();
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxTicksLimit: 50
                            },
                            grid: {
                                color: function(context) {
                                    const value = context.tick.value;
                                    const log = Math.log10(value);
                                    // Major grid lines (powers of 10) - more visible
                                    if (Math.abs(log - Math.round(log)) < 0.001) {
                                        return 'rgba(0, 0, 0, 0.15)';
                                    }
                                    // Minor grid lines (2,3,4,5,6,7,8,9) - barely visible
                                    return 'rgba(0, 0, 0, 0.03)';
                                }
                            },
                            afterBuildTicks: function(axis) {
                                // Generate all powers of 10 from 10K to 100B
                                const ticks = [];
                                const minPower = 4; // Start at 10^4 = 10,000
                                const maxPower = 11; // End at 10^11 = 100,000,000,000
                                
                                for (let power = minPower; power <= maxPower; power++) {
                                    const base = Math.pow(10, power);
                                    // Add major tick (power of 10)
                                    ticks.push({ value: base });
                                    // Add minor ticks (2,3,4,5,6,7,8,9) only if not at max power
                                    if (power < maxPower) {
                                        for (let i = 2; i <= 9; i++) {
                                            const minorValue = base * i;
                                            if (minorValue <= axis.max) {
                                                ticks.push({ value: minorValue });
                                            }
                                        }
                                    }
                                }
                                axis.ticks = ticks;
                            }
                        }
                    }
                }
            });
        }

        // Error handling
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">‚ùå ${message}</div>`;
        }

        function clearError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        // Start the app
        init();
    </script>
</body>
</html>
