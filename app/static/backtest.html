<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtest Results - PyTAAA Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin-bottom: 20px;
            transition: background 0.3s;
        }
        
        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        label {
            font-weight: 600;
            color: #333;
        }
        
        select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            background: white;
            color: #333;
            min-width: 200px;
        }
        
        select:focus {
            outline: none;
            border-color: #764ba2;
        }
        
        .chart-container {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 500px;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        h2 {
            margin: 0;
            color: #333;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .chart-controls label {
            font-weight: 600;
            color: #333;
        }
        
        .chart-controls select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            background: white;
            color: #333;
            min-width: 200px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-size: 1.2rem;
        }
        
        .error {
            background: #fee;
            border: 2px solid #fcc;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #c33;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/static/dashboard.html" class="back-link">‚Üê Back to Dashboard</a>
            <h1>üìà Backtest Results</h1>
            <p class="subtitle">Historical model performance analysis</p>
        </header>

        <div id="errorContainer"></div>

        <!-- Phase 5A MVP: Subplot 1 - Portfolio Value Comparison -->
        <div class="chart-container">
            <div class="chart-header">
                <h2>Portfolio Value: All Models vs Buy-and-Hold</h2>
                <div class="chart-controls">
                    <label for="periodSelect">Time Period:</label>
                    <select id="periodSelect">
                        <option value="30">1 month</option>
                        <option value="90">3 months</option>
                        <option value="180">6 months</option>
                        <option value="ytd">YTD</option>
                        <option value="365">1 year</option>
                        <option value="730">2 years</option>
                        <option value="1095">3 years</option>
                        <option value="1825">5 years</option>
                        <option value="3650">10 years</option>
                        <option value="max" selected>max</option>
                    </select>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="portfolioChart"></canvas>
            </div>
        </div>

        <!-- Phase 5C: Subplot 2 - Model Selection Timeline -->
        <div class="chart-container">
            <h2>Model Selection Timeline (which model should have been selected)</h2>
            <div class="chart-wrapper" style="height: 169px; min-height: 169px;">
                <canvas id="modelSelectionChart"></canvas>
            </div>
        </div>

        <!-- Phase 5B: Subplot 3 - NASDAQ 100 Market Breadth -->
        <div class="chart-container">
            <h2>NASDAQ 100 Market Breadth: New Highs vs New Lows</h2>
            <div class="chart-wrapper" style="height: 125px; min-height: 125px;">
                <canvas id="breadthChartNasdaq"></canvas>
            </div>
        </div>

        <!-- Phase 5B: Subplot 4 - S&P 500 Market Breadth -->
        <div class="chart-container">
            <h2>S&P 500 Market Breadth: New Highs vs New Lows</h2>
            <div class="chart-wrapper" style="height: 125px; min-height: 125px;">
                <canvas id="breadthChartSp500"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let models = [];
        let currentModelId = null;
        let portfolioChart = null;
        let breadthChartNasdaq = null;
        let breadthChartSp500 = null;
        let modelSelectionChart = null;
        let sharedXAxisConfig = null;

        // Helper function to calculate days from start of year to today
        function getDaysFromYTD() {
            const now = new Date();
            const startOfYear = new Date(now.getFullYear(), 0, 1);
            const diffTime = Math.abs(now - startOfYear);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        }

        // Chart colors (matching specification from ROADMAP.md)
        const COLORS = {
            // Individual model portfolio curves (3px)
            naz100_pine: 'rgb(0, 123, 220)',      // Blue
            naz100_hma: 'rgb(220, 0, 0)',          // Red
            naz100_pi: 'rgb(0, 220, 0)',           // Green
            sp500_hma: 'rgb(0, 206, 209)',         // Cyan
            sp500_pine: 'rgb(250, 0, 250)',        // Magenta (bright)
            
            // Meta-model (naz100_sp500_abacus) - bold 5px
            metaModel: 'rgb(25, 25, 25)',          // Black
            
            // Buy and Hold curves (1px thin)
            buyHoldNaz: 'rgb(128, 20, 20)',        // Dark red
            buyHoldSp: 'rgb(20, 20, 128)',         // Dark blue
            
            // CASH dot for model selection
            cash: 'rgb(25, 25, 25)'                // Black
        };

        // Initialize
        async function init() {
            try {
                await loadModels();
                setupEventListeners();
            } catch (error) {
                showError('Failed to initialize: ' + error.message);
            }
        }

        // Load available models
        async function loadModels() {
            try {
                const response = await fetch('/api/v1/models');
                if (!response.ok) throw new Error('Failed to fetch models');
                
                models = await response.json();
                
                // Load all models' backtest data
                const period = document.getElementById('periodSelect').value;
                await loadAllModelsBacktestData(period);
            } catch (error) {
                showError('Failed to load models: ' + error.message);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            const periodSelect = document.getElementById('periodSelect');
            
            periodSelect.addEventListener('change', async (e) => {
                const period = e.target.value;
                
                console.log('Period changed to:', period);
                
                // Reload all charts
                await loadAllModelsBacktestData(period);
            });
        }

        // Load backtest data for all models
        async function loadAllModelsBacktestData(days = 'max') {
            try {
                clearError();
                
                // Build query parameter
                const daysParam = days === 'max' ? 'days=100000' : (days === 'ytd' ? `days=${getDaysFromYTD()}` : `days=${days}`);
                
                console.log('loadAllModelsBacktestData called with days:', days);
                
                // Fetch backtest data for all models in parallel
                const backtestPromises = models.map(async model => {
                    try {
                        const url = `/api/v1/models/${model.id}/backtest?${daysParam}`;
                        const response = await fetch(url);
                        if (!response.ok) {
                            console.warn(`No backtest data for ${model.name}`);
                            return null;
                        }
                        return await response.json();
                    } catch (error) {
                        console.error(`Error fetching backtest for ${model.name}:`, error);
                        return null;
                    }
                });
                
                const allBacktestData = await Promise.all(backtestPromises);
                const validBacktestData = allBacktestData.filter(data => data !== null);
                
                if (validBacktestData.length === 0) {
                    throw new Error('No backtest data available for any model. Please ingest data first.');
                }
                
                // Calculate shared x-axis range from all data
                let allDates = [];
                validBacktestData.forEach(data => {
                    const dates = data.data_points.map(d => new Date(d.date));
                    allDates = allDates.concat(dates);
                });
                
                sharedXAxisConfig = {
                    min: new Date(Math.min(...allDates)),
                    max: new Date(Math.max(...allDates))
                };
                
                renderPortfolioChartAllModels(validBacktestData);
                await loadAndRenderBreadthCharts(days);
                await loadAndRenderModelSelectionChart(days);
            } catch (error) {
                showError(error.message);
                if (portfolioChart) {
                    portfolioChart.destroy();
                    portfolioChart = null;
                }
                if (breadthChartNasdaq) {
                    breadthChartNasdaq.destroy();
                    breadthChartNasdaq = null;
                }
                if (breadthChartSp500) {
                    breadthChartSp500.destroy();
                    breadthChartSp500 = null;
                }
                if (modelSelectionChart) {
                    modelSelectionChart.destroy();
                    modelSelectionChart = null;
                }
            }
        }

        // Render Portfolio Value Chart with All Models (Subplot 1)
        function renderPortfolioChartAllModels(allBacktestData) {
            const ctx = document.getElementById('portfolioChart');
            
            if (portfolioChart) {
                portfolioChart.destroy();
            }
            
            // Prepare datasets for all models
            const datasets = [];
            
            // Track buy-and-hold data (only need one per index type)
            let nasdaqBuyHold = null;
            let sp500BuyHold = null;
            
            // Add individual model lines
            allBacktestData.forEach(data => {
                const dates = data.data_points.map(d => d.date);
                const tradedValues = data.data_points.map(d => d.traded_value);
                const buyHoldValues = data.data_points.map(d => d.buy_hold_value);
                
                // Store buy-and-hold data for later (skip meta-model for B&H baseline)
                const isMetaModel = data.model_name === 'naz100_sp500_abacus';
                if (data.index_type === 'NASDAQ_100' && !nasdaqBuyHold && !isMetaModel) {
                    nasdaqBuyHold = { dates, values: buyHoldValues };
                } else if (data.index_type === 'SP_500' && !sp500BuyHold && !isMetaModel) {
                    sp500BuyHold = { dates, values: buyHoldValues };
                }
                
                // Add model's traded portfolio line
                const modelColor = COLORS[data.model_name] || COLORS.metaModel;
                
                datasets.push({
                    label: data.model_name,
                    data: dates.map((date, i) => ({ x: date, y: tradedValues[i] })),
                    borderColor: modelColor,
                    backgroundColor: 'transparent',
                    borderWidth: isMetaModel ? 3 : 2,  // 3px for meta-model, 2px for others
                    pointRadius: 0,
                    tension: 0,
                    order: isMetaModel ? 0 : 1  // Meta-model on top
                });
            });
            
            // Add buy-and-hold lines (after model lines for proper layering)
            if (nasdaqBuyHold) {
                datasets.push({
                    label: 'Buy & Hold (NASDAQ 100)',
                    data: nasdaqBuyHold.dates.map((date, i) => ({ x: date, y: nasdaqBuyHold.values[i] })),
                    borderColor: COLORS.buyHoldNaz,
                    backgroundColor: 'transparent',
                    borderWidth: 1,  // 1px thin for buy-and-hold
                    pointRadius: 0,
                    tension: 0,
                    order: 2  // Buy-and-hold behind models
                });
            }
            
            if (sp500BuyHold) {
                datasets.push({
                    label: 'Buy & Hold (S&P 500)',
                    data: sp500BuyHold.dates.map((date, i) => ({ x: date, y: sp500BuyHold.values[i] })),
                    borderColor: COLORS.buyHoldSp,
                    backgroundColor: 'transparent',
                    borderWidth: 1,  // 1px thin for buy-and-hold
                    pointRadius: 0,
                    tension: 0,
                    order: 2  // Buy-and-hold behind models
                });
            }
            
            portfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 0
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'chartArea',
                            align: 'start',
                            labels: {
                                usePointStyle: false,
                                boxWidth: 60,
                                boxHeight: 1.5
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: sharedXAxisConfig?.min,
                            max: sharedXAxisConfig?.max,
                            time: {
                                unit: 'year',
                                stepSize: 1,  // Generate ticks every year
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            },
                            ticks: {
                                callback: function(value, index, ticks) {
                                    const date = new Date(value);
                                    const year = date.getFullYear();
                                    // Only show label for years divisible by 5
                                    if (year % 5 === 0) {
                                        return year;
                                    }
                                    return '';  // Empty label for minor ticks
                                },
                                major: {
                                    enabled: true
                                },
                                autoSkip: false,  // Don't auto-skip to ensure all ticks are generated
                                maxRotation: 0,
                                minRotation: 0
                            },
                            grid: {
                                display: true,
                                color: function(context) {
                                    if (context.tick && context.tick.value) {
                                        const date = new Date(context.tick.value);
                                        const year = date.getFullYear();
                                        // Draw major grid lines (every 5 years) darker
                                        if (year % 5 === 0) {
                                            return 'rgba(0, 0, 0, 0.15)';
                                        }
                                    }
                                    return 'rgba(0, 0, 0, 0.05)';
                                }
                            },
                            afterFit: function(scaleInstance) {
                                scaleInstance.height = 50; // Fixed height for x-axis
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            min: 10000, // Start at $10K
                            max: 100000000000, // 100B
                            title: {
                                display: true,
                                text: 'Portfolio Value ($) - Log Scale'
                            },
                            afterFit: function(scaleInstance) {
                                scaleInstance.width = 80; // Fixed width for y-axis
                            },
                            ticks: {
                                autoSkip: false,
                                maxTicksLimit: 50,
                                callback: function(value) {
                                    // Only show major ticks (powers of 10)
                                    const log = Math.log10(value);
                                    if (Math.abs(log - Math.round(log)) < 0.001) {
                                        // Format as K, M, B with spaces
                                        if (value >= 1000000000) {
                                            return '$' + (value / 1000000000) + ' B';
                                        } else if (value >= 1000000) {
                                            return '$' + (value / 1000000) + ' M';
                                        } else if (value >= 1000) {
                                            return '$' + (value / 1000) + 'K';
                                        }
                                        return '$' + value.toLocaleString();
                                    }
                                    return '';
                                },
                                autoSkip: false,
                                maxTicksLimit: 50
                            },
                            grid: {
                                color: function(context) {
                                    const value = context.tick.value;
                                    const log = Math.log10(value);
                                    // Major grid lines (powers of 10) - more visible
                                    if (Math.abs(log - Math.round(log)) < 0.001) {
                                        return 'rgba(0, 0, 0, 0.15)';
                                    }
                                    // Minor grid lines (2,3,4,5,6,7,8,9) - barely visible
                                    return 'rgba(0, 0, 0, 0.03)';
                                }
                            },
                            afterBuildTicks: function(axis) {
                                // Generate all powers of 10 from 10K to 100B
                                const ticks = [];
                                const minPower = 4; // Start at 10^4 = 10,000
                                const maxPower = 11; // End at 10^11 = 100,000,000,000
                                
                                for (let power = minPower; power <= maxPower; power++) {
                                    const base = Math.pow(10, power);
                                    // Add major tick (power of 10)
                                    ticks.push({ value: base });
                                    // Add minor ticks (2,3,4,5,6,7,8,9) only if not at max power
                                    if (power < maxPower) {
                                        for (let i = 2; i <= 9; i++) {
                                            const minorValue = base * i;
                                            if (minorValue <= axis.max) {
                                                ticks.push({ value: minorValue });
                                            }
                                        }
                                    }
                                }
                                axis.ticks = ticks;
                            }
                        }
                    }
                }
            });
        }

        // Load and render both breadth charts
        async function loadAndRenderBreadthCharts(days = 'max') {
            try {
                console.log('loadAndRenderBreadthCharts called with days:', days);
                console.log('Loading breadth charts, models available:', models.length);
                
                // Build query parameter
                const daysParam = days === 'max' ? 'days=100000' : (days === 'ytd' ? `days=${getDaysFromYTD()}` : `days=${days}`);
                
                // Find models with backtest data
                const nasdaqModels = models.filter(m => !m.is_meta && m.index_type === 'NASDAQ_100');
                const sp500Models = models.filter(m => !m.is_meta && m.index_type === 'SP_500');
                
                console.log('NASDAQ models:', nasdaqModels.map(m => m.name));
                console.log('SP500 models:', sp500Models.map(m => m.name));
                
                if (nasdaqModels.length === 0 || sp500Models.length === 0) {
                    console.warn('Could not find both NASDAQ and S&P 500 models for breadth charts');
                    showError('Need both NASDAQ and S&P 500 models for breadth indicators');
                    return;
                }
                
                // Try to fetch data from available models
                let nasdaqData = null;
                let nasdaqModel = null;
                
                for (const model of nasdaqModels) {
                    console.log(`Trying NASDAQ model: ${model.name}`);
                    const response = await fetch(`/api/v1/models/${model.id}/backtest?${daysParam}`);
                    if (response.ok) {
                        nasdaqData = await response.json();
                        nasdaqModel = model;
                        console.log(`Success: ${model.name} has ${nasdaqData.data_points.length} data points`);
                        break;
                    } else {
                        console.log(`Failed: ${model.name} - Status ${response.status}`);
                    }
                }
                
                let sp500Data = null;
                let sp500Model = null;
                
                for (const model of sp500Models) {
                    console.log(`Trying SP500 model: ${model.name}`);
                    const response = await fetch(`/api/v1/models/${model.id}/backtest?${daysParam}`);
                    if (response.ok) {
                        sp500Data = await response.json();
                        sp500Model = model;
                        console.log(`Success: ${model.name} has ${sp500Data.data_points.length} data points`);
                        break;
                    } else {
                        console.log(`Failed: ${model.name} - Status ${response.status}`);
                    }
                }
                
                if (!nasdaqData || !sp500Data) {
                    const missing = [];
                    if (!nasdaqData) missing.push('NASDAQ');
                    if (!sp500Data) missing.push('S&P 500');
                    showError(`No backtest data available for ${missing.join(' and ')} models. Please run: python -m app.cli.ingest --backtest --model <model_name>`);
                    return;
                }
                
                console.log('NASDAQ data points:', nasdaqData.data_points.length);
                console.log('SP500 data points:', sp500Data.data_points.length);
                
                // sharedXAxisConfig already set from portfolio chart
                // Just verify both datasets are within range
                console.log('Using shared x-axis range:', sharedXAxisConfig);
                
                console.log('Rendering breadth charts...');
                // Render both charts
                renderBreadthChart(nasdaqData, 'breadthChartNasdaq', true, false);  // Show labels, hide title
                renderBreadthChart(sp500Data, 'breadthChartSp500', true, true);     // Show labels, show title
                console.log('Breadth charts rendered successfully');
            } catch (error) {
                console.error('Error loading breadth charts:', error);
                showError('Error loading breadth charts: ' + error.message);
            }
        }

        // Render Market Breadth Chart
        function renderBreadthChart(data, canvasId, showXAxisLabels, showXAxisTitle) {
            console.log(`renderBreadthChart called for ${canvasId}, data points: ${data.data_points.length}`);
            const ctx = document.getElementById(canvasId);
            
            if (!ctx) {
                console.error(`Canvas element not found: ${canvasId}`);
                return;
            }
            
            console.log('Canvas element found:', ctx);
            
            // Destroy existing chart
            if (canvasId === 'breadthChartNasdaq' && breadthChartNasdaq) {
                breadthChartNasdaq.destroy();
            } else if (canvasId === 'breadthChartSp500' && breadthChartSp500) {
                breadthChartSp500.destroy();
            }
            
            // Prepare datasets
            const dates = data.data_points.map(d => d.date);
            const newHighs = data.data_points.map(d => d.new_highs);
            const newLows = data.data_points.map(d => d.new_lows);
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [
                        {
                            label: 'New Highs',
                            data: newHighs,
                            borderColor: '#2ca02c',  // Green
                            backgroundColor: 'transparent',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            tension: 0
                        },
                        {
                            label: 'New Lows',
                            data: newLows,
                            borderColor: '#d62728',  // Red
                            backgroundColor: 'transparent',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 0
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'chartArea',
                            align: 'start',
                            labels: {
                                usePointStyle: false,
                                boxWidth: 60,
                                boxHeight: 1.5
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: sharedXAxisConfig?.min,
                            max: sharedXAxisConfig?.max,
                            time: {
                                unit: 'year',
                                stepSize: 1,  // Generate ticks every year
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            title: {
                                display: showXAxisTitle,
                                text: 'Date'
                            },
                            ticks: {
                                display: showXAxisLabels,
                                callback: function(value, index, ticks) {
                                    if (!showXAxisLabels) return '';
                                    const date = new Date(value);
                                    const year = date.getFullYear();
                                    // Only show label for years divisible by 5
                                    if (year % 5 === 0) {
                                        return year;
                                    }
                                    return '';  // Empty label for minor ticks
                                },
                                major: {
                                    enabled: true
                                },
                                autoSkip: false,  // Don't auto-skip to ensure all ticks are generated
                                maxRotation: 0,
                                minRotation: 0
                            },
                            grid: {
                                display: true,
                                drawTicks: true,
                                color: function(context) {
                                    if (context.tick && context.tick.value) {
                                        const date = new Date(context.tick.value);
                                        const year = date.getFullYear();
                                        // Draw major grid lines (every 5 years) darker
                                        if (year % 5 === 0) {
                                            return 'rgba(0, 0, 0, 0.15)';
                                        }
                                    }
                                    return 'rgba(0, 0, 0, 0.05)';
                                }
                            },
                            afterFit: function(scaleInstance) {
                                scaleInstance.height = 50; // Fixed height for x-axis (matches other charts)
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            afterFit: function(scaleInstance) {
                                scaleInstance.width = 80; // Fixed width for y-axis (matches portfolio chart)
                            },
                            ticks: {
                                precision: 0,
                                autoSkip: false
                            }
                        }
                    }
                }
            });
            
            // Store chart reference
            if (canvasId === 'breadthChartNasdaq') {
                breadthChartNasdaq = chart;
            } else if (canvasId === 'breadthChartSp500') {
                breadthChartSp500 = chart;
            }
        }

        // Load and render model selection timeline (Phase 5C)
        async function loadAndRenderModelSelectionChart(days = 'max') {
            try {
                console.log('loadAndRenderModelSelectionChart called with days:', days);
                
                // Find meta-model
                const metaModel = models.find(m => m.is_meta);
                if (!metaModel) {
                    console.log('No meta-model found, skipping model selection chart');
                    return;
                }
                
                // Build query parameters - use backtest endpoint instead of selections
                const daysParam = days === 'max' ? 'days=100000' : (days === 'ytd' ? `days=${getDaysFromYTD()}` : `days=${days}`);
                const url = `/api/v1/models/${metaModel.id}/backtest?${daysParam}`;
                
                console.log('Fetching abacus backtest data from:', url);
                const response = await fetch(url);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('No backtest data for meta-model, skipping model selection chart');
                        return;
                    }
                    throw new Error('Failed to fetch abacus backtest data');
                }
                
                const backtestData = await response.json();
                console.log('Abacus backtest data points:', backtestData.data_points.length);
                
                // Filter to first day of each month only
                const monthlySelections = filterToFirstDayOfMonth(backtestData.data_points);
                console.log('Monthly selection points:', monthlySelections.length);
                
                renderModelSelectionChart(monthlySelections);
            } catch (error) {
                console.error('Error loading model selection chart:', error);
                // Don't show error to user - this chart is optional
            }
        }
        
        // Filter data points to first day of each month
        function filterToFirstDayOfMonth(dataPoints) {
            const monthlyPoints = [];
            let lastMonth = null;
            
            for (const point of dataPoints) {
                if (!point.selected_model) continue;  // Skip if no selected_model field
                
                const date = new Date(point.date);
                const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
                
                if (monthKey !== lastMonth) {
                    monthlyPoints.push(point);
                    lastMonth = monthKey;
                }
            }
            
            return monthlyPoints;
        }

        // Render Model Selection Timeline Chart (Subplot 4)
        function renderModelSelectionChart(monthlySelections) {
            const ctx = document.getElementById('modelSelectionChart');
            
            if (!ctx) {
                console.error('Canvas element not found: modelSelectionChart');
                return;
            }
            
            if (modelSelectionChart) {
                modelSelectionChart.destroy();
            }
            
            // Get unique model names from selections
            const uniqueModels = [...new Set(monthlySelections.map(s => s.selected_model))];
            
            // Define display order to match upper chart legend (alphabetical by model name)
            const modelOrder = ['naz100_hma', 'naz100_pine', 'naz100_pi', 'sp500_hma', 'sp500_pine', 'naz100_sp500_abacus', 'CASH'];
            const modelNames = modelOrder.filter(name => uniqueModels.includes(name));
            
            // Create color mapping for models - use consistent colors from COLORS constant
            const modelColors = {
                'naz100_pine': COLORS.naz100_pine,   // Blue
                'naz100_hma': COLORS.naz100_hma,     // Red
                'naz100_pi': COLORS.naz100_pi,       // Green
                'sp500_hma': COLORS.sp500_hma,       // Cyan
                'sp500_pine': COLORS.sp500_pine,     // Magenta
                'sp500_pi': COLORS.sp500_pine,       // Magenta (if exists, same as sp500_pine)
                'naz100_sp500_abacus': COLORS.metaModel,  // Black for meta-model
                'CASH': 'rgb(25, 25, 25)'            // Black for cash
            };
            
            // Prepare data points - each selection becomes a scatter point
            const datasets = modelNames.map(modelName => {
                const points = monthlySelections
                    .filter(s => s.selected_model === modelName)
                    .map(s => ({
                        x: s.date,
                        y: modelName
                    }));
                
                return {
                    label: modelName,
                    data: points,
                    backgroundColor: modelColors[modelName] || '#999',
                    borderColor: modelColors[modelName] || '#999',
                    pointRadius: 3,
                    pointHoverRadius: 5
                };
            });
            
            modelSelectionChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    layout: {
                        padding: {
                            bottom: 0  // Reduce space between chart and legend
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            labels: {
                                boxWidth: 7,
                                font: { size: 12 },
                                padding: 20,  // Increased horizontal spacing between entries
                                usePointStyle: true,
                                pointStyleWidth: 7
                            }
                        },
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: sharedXAxisConfig?.min,
                            max: sharedXAxisConfig?.max,
                            time: {
                                unit: 'year',
                                stepSize: 1,
                                displayFormats: {
                                    year: 'yyyy'
                                }
                            },
                            title: {
                                display: false
                            },
                            ticks: {
                                display: true,
                                callback: function(value, index, ticks) {
                                    const date = new Date(value);
                                    const year = date.getFullYear();
                                    // Only show label for years divisible by 5
                                    if (year % 5 === 0) {
                                        return year;
                                    }
                                    return '';  // Empty label for minor ticks
                                },
                                major: {
                                    enabled: true
                                },
                                autoSkip: false,
                                maxRotation: 0,
                                minRotation: 0
                            },
                            grid: {
                                display: true,
                                drawTicks: true,
                                color: function(context) {
                                    if (context.tick && context.tick.value) {
                                        const date = new Date(context.tick.value);
                                        const year = date.getFullYear();
                                        // Draw major grid lines (every 5 years) darker
                                        if (year % 5 === 0) {
                                            return 'rgba(0, 0, 0, 0.15)';
                                        }
                                    }
                                    return 'rgba(0, 0, 0, 0.05)';
                                }
                            },
                            afterFit: function(scaleInstance) {
                                scaleInstance.height = 25; // Minimize whitespace above legend
                            }
                        },
                        y: {
                            type: 'category',
                            labels: modelNames,
                            title: {
                                display: false
                            },
                            grid: {
                                display: true,
                                drawBorder: true,
                                drawOnChartArea: true,
                                color: 'rgba(0, 0, 0, 0.15)',  // Slightly darker for visibility
                                lineWidth: 1
                            },
                            afterFit: function(scaleInstance) {
                                scaleInstance.width = 120; // Increased from 80 to accommodate model names
                            },
                            ticks: {
                                display: true,
                                font: {
                                    size: 10  // Slightly larger for readability
                                },
                                color: '#333',
                                autoSkip: false  // Show all model labels
                            }
                        }
                    }
                }
            });
        }

        // Error handling
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">‚ùå ${message}</div>`;
        }

        function clearError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        // Start the app
        init();
    </script>
</body>
</html>
