<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Comparison - PyTAAA Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            zoom: 0.85;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .back-link {
            display: inline-block;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin-bottom: 20px;
            transition: background 0.3s;
        }
        
        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .period-select {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            background: white;
            color: #333;
            transition: border-color 0.3s;
            flex-shrink: 0;
        }
        
        .period-value-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .period-select:hover {
            border-color: #764ba2;
        }
        
        .period-select:focus {
            outline: none;
            border-color: #764ba2;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 500px;
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .legend-color {
            width: 30px;
            height: 15px;
            border-radius: 3px;
            margin-right: 10px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .legend-color-text {
            color: white;
            font-size: 8px;
            font-weight: bold;
            letter-spacing: 0.5px;
            position: absolute;
        }
        
        .legend-name {
            font-weight: 600;
            flex: 1;
            font-size: 12px;
        }
        

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            color: #667eea;
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/" class="back-link">‚Üê Back to Dashboard</a>
            <h1>üìä Model Performance Comparison</h1>
            <p class="subtitle">Compare all trading models side-by-side</p>
        </header>
        
        <div id="statsContainer"></div>
        
        <div class="chart-container">
            <h2 style="margin-bottom: 20px; color: #333;">Equity Curves Comparison</h2>
            <div class="chart-wrapper">
                <canvas id="comparisonChart"></canvas>
            </div>
            <div id="legendContainer" class="legend"></div>
        </div>
        
        <div id="loading" class="loading" style="display: none;">Loading comparison data...</div>
    </div>
    
    <script>
        let chart = null;
        
        // Color palettes by index type
        const nasdaq100Colors = [
            { border: 'rgb(220, 53, 69)', bg: 'rgba(220, 53, 69, 0.1)' },      // Red
            { border: 'rgb(255, 159, 64)', bg: 'rgba(255, 159, 64, 0.1)' },    // Orange
            { border: 'rgb(255, 206, 86)', bg: 'rgba(255, 206, 86, 0.1)' }     // Yellow
        ];
        
        const sp500Colors = [
            { border: 'rgb(34, 139, 34)', bg: 'rgba(34, 139, 34, 0.1)' },      // Forest Green
            { border: 'rgb(0, 206, 209)', bg: 'rgba(0, 206, 209, 0.1)' },      // Dark Turquoise
            { border: 'rgb(0, 123, 255)', bg: 'rgba(0, 123, 255, 0.1)' }       // Blue
        ];
        
        const metaColor = { border: 'rgb(0, 0, 0)', bg: 'rgba(0, 0, 0, 0.05)' };  // Black for meta-model
        
        function getModelColor(model, nasdaqCount, sp500Count) {
            if (model.is_meta) {
                return metaColor;
            }
            
            // Assign color based on index type
            if (model.index_type === 'NASDAQ_100') {
                const colorIdx = nasdaqCount % nasdaq100Colors.length;
                return nasdaq100Colors[colorIdx];
            } else if (model.index_type === 'SP_500') {
                const colorIdx = sp500Count % sp500Colors.length;
                return sp500Colors[colorIdx];
            }
            
            // Fallback for unknown index types
            return { border: 'rgb(128, 128, 128)', bg: 'rgba(128, 128, 128, 0.1)' };
        }
        
        async function loadComparison() {
            const daysSelect = document.getElementById('daysSelect');
            let days = daysSelect ? daysSelect.value : 365;
            
            // Handle YTD and max
            if (days === 'ytd') {
                const now = new Date();
                const startOfYear = new Date(now.getFullYear(), 0, 1);
                days = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
            } else if (days === 'max') {
                days = 100000; // Large number to get all available data
            }
            
            const loadingEl = document.getElementById('loading');
            
            loadingEl.style.display = 'block';
            
            try {
                const response = await fetch(`/api/v1/models/compare?days=${days}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data || !data.models || data.models.length === 0) {
                    throw new Error('No model data returned');
                }
                
                renderChart(data);
                renderStats(data);
                renderLegend(data);
            } catch (error) {
                console.error('Error loading comparison:', error);
                const chartCard = document.getElementById('chartCard');
                if (chartCard) {
                    chartCard.innerHTML = `<div style="text-align: center; padding: 40px; color: #dc3545;">
                        <h3>Failed to load comparison data</h3>
                        <p>${error.message}</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">Check console for details</p>
                    </div>`;
                }
            } finally {
                loadingEl.style.display = 'none';
            }
        }
        
        function renderChart(data) {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            
            // Destroy existing chart
            if (chart) {
                chart.destroy();
            }
            
            // Prepare datasets
            let nasdaqCount = 0;
            let sp500Count = 0;
            
            const datasets = data.models.map((model) => {
                let color;
                
                if (model.is_meta) {
                    color = metaColor;
                } else if (model.index_type === 'NASDAQ_100') {
                    color = nasdaq100Colors[nasdaqCount % nasdaq100Colors.length];
                    nasdaqCount++;
                } else if (model.index_type === 'SP_500') {
                    color = sp500Colors[sp500Count % sp500Colors.length];
                    sp500Count++;
                } else {
                    color = { border: 'rgb(128, 128, 128)', bg: 'rgba(128, 128, 128, 0.1)' };
                }
                
                return {
                    label: model.model_name,
                    data: model.data_points.map(dp => ({
                        x: dp.date,
                        y: dp.traded_value
                    })),
                    borderColor: color.border,
                    backgroundColor: color.bg,
                    borderWidth: model.is_meta ? 4 : 2,
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    tension: 0.1,
                    fill: false
                };
            });
            
            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                        axis: 'x'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            filter: function(tooltipItem, data) {
                                // Only show tooltip items that are actually at the same date
                                // Get the x-value (date) of the hovered point
                                const hoveredDate = tooltipItem.parsed.x;
                                const actualDate = tooltipItem.raw.x;
                                
                                // Check if this point's date matches the hovered date within 1 day tolerance
                                const dateDiff = Math.abs(actualDate - hoveredDate);
                                const oneDayMs = 24 * 60 * 60 * 1000;
                                
                                return dateDiff < oneDayMs;
                            },
                            callbacks: {
                                title: function(context) {
                                    if (context.length > 0) {
                                        // Use the actual date from the first item
                                        const date = new Date(context[0].raw.x);
                                        return date.toLocaleDateString('en-US', { 
                                            year: 'numeric', 
                                            month: 'short', 
                                            day: 'numeric' 
                                        });
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return `${label}: $${value.toLocaleString('en-US', {
                                        minimumFractionDigits: 2,
                                        maximumFractionDigits: 2
                                    })}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month',
                                displayFormats: {
                                    month: 'MMM yyyy'
                                },
                                tooltipFormat: 'MMM d, yyyy'
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 12
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Portfolio Value ($)',
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString('en-US', {
                                        minimumFractionDigits: 0,
                                        maximumFractionDigits: 0
                                    });
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderLegend(data) {
            const container = document.getElementById('legendContainer');
            container.innerHTML = '';
            
            let nasdaqCount = 0;
            let sp500Count = 0;
            
            data.models.forEach((model) => {
                let color;
                
                if (model.is_meta) {
                    color = metaColor;
                } else if (model.index_type === 'NASDAQ_100') {
                    color = nasdaq100Colors[nasdaqCount % nasdaq100Colors.length];
                    nasdaqCount++;
                } else if (model.index_type === 'SP_500') {
                    color = sp500Colors[sp500Count % sp500Colors.length];
                    sp500Count++;
                } else {
                    color = { border: 'rgb(128, 128, 128)', bg: 'rgba(128, 128, 128, 0.1)' };
                }
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${color.border}">
                        ${model.is_meta ? '<span class="legend-color-text">META</span>' : ''}
                    </div>
                    <span class="legend-name">${model.model_name}</span>
                `;
                container.appendChild(item);
            });
        }
        
        function renderStats(data) {
            const container = document.getElementById('statsContainer');
            const models = data.models;
            const currentDays = document.getElementById('daysSelect')?.value || '365';
            
            // Find the common date range (earliest start date among all models with data)
            let earliestDate = null;
            let latestDate = null;
            
            models.forEach(model => {
                if (model.data_points.length > 0) {
                    const modelStart = new Date(model.data_points[0].date);
                    const modelEnd = new Date(model.data_points[model.data_points.length - 1].date);
                    
                    if (!earliestDate || modelStart > earliestDate) {
                        earliestDate = modelStart;  // Use the latest start date
                    }
                    if (!latestDate || modelEnd > latestDate) {
                        latestDate = modelEnd;
                    }
                }
            });
            
            // Calculate statistics using values closest to common date range
            let bestPerformer = null;
            let bestCAGR = -Infinity;
            let bestAbsoluteGain = -Infinity;
            
            models.forEach(model => {
                if (model.data_points.length >= 2) {
                    // Find data points closest to the common date range
                    const firstPoint = model.data_points.find(dp => 
                        new Date(dp.date) >= earliestDate
                    ) || model.data_points[0];
                    
                    const lastPoint = model.data_points[model.data_points.length - 1];
                    
                    const first = firstPoint.traded_value;
                    const last = lastPoint.traded_value;
                    
                    // Calculate CAGR (Compound Annual Growth Rate)
                    const startDate = new Date(firstPoint.date);
                    const endDate = new Date(lastPoint.date);
                    const years = (endDate - startDate) / (365.25 * 24 * 60 * 60 * 1000);
                    
                    let cagr = 0;
                    if (years > 0 && first > 0) {
                        cagr = (Math.pow(last / first, 1 / years) - 1) * 100;
                    }
                    
                    const absoluteGain = last - first;
                    
                    if (cagr > bestCAGR) {
                        bestCAGR = cagr;
                        bestPerformer = model.model_name;
                        bestAbsoluteGain = absoluteGain;
                    }
                }
            });
            
            const metaModel = models.find(m => m.is_meta);
            let metaCAGR = 0;
            let metaAbsoluteGain = 0;
            if (metaModel && metaModel.data_points.length >= 2) {
                const firstPoint = metaModel.data_points.find(dp => 
                    new Date(dp.date) >= earliestDate
                ) || metaModel.data_points[0];
                const lastPoint = metaModel.data_points[metaModel.data_points.length - 1];
                
                const first = firstPoint.traded_value;
                const last = lastPoint.traded_value;
                
                const startDate = new Date(firstPoint.date);
                const endDate = new Date(lastPoint.date);
                const years = (endDate - startDate) / (365.25 * 24 * 60 * 60 * 1000);
                
                if (years > 0 && first > 0) {
                    metaCAGR = (Math.pow(last / first, 1 / years) - 1) * 100;
                }
                metaAbsoluteGain = last - first;
            }
            
            // Find the most recent data date across all models
            let latestDataDate = null;
            models.forEach(model => {
                if (model.data_points.length > 0) {
                    const lastDate = new Date(model.data_points[model.data_points.length - 1].date);
                    if (!latestDataDate || lastDate > latestDataDate) {
                        latestDataDate = lastDate;
                    }
                }
            });
            
            const lastUpdatedText = latestDataDate 
                ? latestDataDate.toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'})
                : 'N/A';
            
            container.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Active Models</h3>
                        <div class="stat-value">${models.length} / ${models.length}</div>
                        <div class="stat-label">Last updated: ${lastUpdatedText}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Best Performer (CAGR)</h3>
                        <div class="stat-value" style="font-size: 1.4rem;">${bestPerformer || 'N/A'} <span style="color: #28a745; margin-left: 10px;">${bestCAGR.toFixed(2)}%</span></div>
                        <div class="stat-label">(+$${bestAbsoluteGain.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})} gain)</div>
                    </div>
                    <div class="stat-card">
                        <h3>Meta-Model CAGR</h3>
                        <div class="stat-value" style="font-size: 1.4rem;">abacus <span style="color: ${metaCAGR >= 0 ? '#28a745' : '#dc3545'}; margin-left: 10px;">${metaCAGR >= 0 ? '+' : ''}${metaCAGR.toFixed(2)}%</span></div>
                        <div class="stat-label">(${metaAbsoluteGain >= 0 ? '+' : ''}$${metaAbsoluteGain.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})} gain)</div>
                    </div>
                    <div class="stat-card">
                        <h3>Time Period</h3>
                        <div class="period-value-row">
                            <div class="stat-value">${data.days}</div>
                            <select id="daysSelect" class="period-select" onchange="loadComparison()">
                                <option value="30" ${currentDays == 30 ? 'selected' : ''}>1 month</option>
                                <option value="90" ${currentDays == 90 ? 'selected' : ''}>3 months</option>
                                <option value="180" ${currentDays == 180 ? 'selected' : ''}>6 months</option>
                                <option value="ytd" ${currentDays == 'ytd' ? 'selected' : ''}>YTD</option>
                                <option value="365" ${currentDays == 365 ? 'selected' : ''}>1 year</option>
                                <option value="730" ${currentDays == 730 ? 'selected' : ''}>2 years</option>
                                <option value="1095" ${currentDays == 1095 ? 'selected' : ''}>3 years</option>
                                <option value="1825" ${currentDays == 1825 ? 'selected' : ''}>5 years</option>
                                <option value="3650" ${currentDays == 3650 ? 'selected' : ''}>10 years</option>
                                <option value="max" ${currentDays == 'max' ? 'selected' : ''}>max</option>
                            </select>
                        </div>
                        <div class="stat-label">Calendar Days</div>
                    </div>
                </div>
            `;
        }
        
        // Load comparison on page load
        window.addEventListener('DOMContentLoaded', loadComparison);
    </script>
</body>
</html>
